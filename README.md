# DAT-Merge-Tool - Инструмент для сравнения данных в директориях

Java-инструмент для рекурсивного сравнения данных (JSON и текстовых блоков ItemName) в двух директориях с выявлением добавленных, удаленных и измененных элементов.

## Структура проекта

```
DiffChange/
├── pom.xml
├── src/
│   ├── main/
│   │   ├── java/
│   │   │   └── org/
│   │   │       └── example/
│   │   │           ├── Main.java                    # Точка входа
│   │   │           ├── comparator/
│   │   │           │   ├── DataComparator.java      # Контракт компараторов
│   │   │           │   ├── FileComparator.java      # Обход директорий
│   │   │           │   ├── JsonComparator.java      # Сравнение JSON
│   │   │           │   └── ItemNameComparator.java  # Сравнение блоков item_name_*
│   │   │           ├── dto/
│   │   │           │   └── DiffResult.java          # DTO для результатов
│   │   │           └── writer/
│   │   │               └── DiffWriter.java           # Запись результатов
│   │   └── resources/
│   └── test/
└── diff/
    ├── old/                                          # Старые файлы
    ├── new/                                          # Новые файлы
    └── output/                                       # Результаты сравнения
```

## Возможности

- ✅ Рекурсивный обход директорий
- ✅ Сравнение JSON-файлов по ID
- ✅ Выявление добавленных элементов
- ✅ Выявление удаленных элементов
- ✅ Выявление измененных полей
- ✅ Обнаружение изменений структуры (новые/удаленные поля, изменение типов)
- ✅ Безопасная обработка ошибок (поврежденный JSON/текст, отсутствующие файлы)
- ✅ Вывод результатов в JSON-формате
- ✅ Поддержка формата ItemName (`item_name_begin` / `item_name_end`)
- ✅ Поддержка конфигурационных файлов (INI / `section` + `key=value`)

## Требования

- Java 21+
- Maven 3.6+

## Сборка проекта

```bash
mvn clean compile
```

## Запуск

```bash
mvn exec:java -Dexec.mainClass="org.example.Main"
```

Или после компиляции:

```bash
java -cp target/classes org.example.Main
```

## Форматы входных данных

### JSON

Полностью поддерживаются объекты и массивы. Для массивов элементы сопоставляются по полю `id`. Изменения значений фиксируются в `changed`, добавление/удаление полей — в `structureChanges`.

### ItemName (`*.txt`)
- ### Конфигурационные (INI) файлы

Файлы с секциями `[Section]` и строками `ключ=значение`. При сравнении каждая пара `section.key` считается отдельной записью. Результат экспорта повторяет исходный формат: секции и их порядок сохраняются.


Файлы вида `ItemName_ClassicAden-eu.txt`, где каждый объект обрамлен маркерами:

```
item_name_begin
    id=94174    name=[Some name]    additionalname=[Sealed]    ...
    description=[Текст описания]
item_name_end
```

- Внутри блока поле задается как `ключ=значение` или `ключ=[значение]`.
- Поля разделены табуляцией (`\t`), но могут располагаться и в новых строках.
- Объекты сравниваются по `id`.
- Изменения значений попадают в `changed`, появление/удаление полей — в `structureChanges`.

## Формат результатов

Для каждого файла создается `<file>.diff.json` в директории `diff/output` со следующей структурой:

```json
{
  "removed": [...],           // Элементы, присутствующие только в OLD
  "added": [...],             // Элементы, присутствующие только в NEW
  "changed": [                // Измененные поля объектов
    {
      "id": "...",
      "field": "...",
      "old": "...",
      "new": "..."
    }
  ],
  "structureChanges": [       // Изменения структуры
    {
      "type": "new_field|removed_field|type_mismatch|format_change",
      "description": "...",
      "id": "..."             // ID объекта (если применимо)
    }
  ]
}
```

## Примеры использования

### Запуск на тестовых данных

1. Убедитесь, что директории `diff/old` и `diff/new` содержат пары файлов (JSON или ItemName)
2. Запустите программу
3. Результаты будут сохранены в `diff/output/`

## Архитектура

Проект следует принципам SOLID:

- **Single Responsibility**: каждый класс отвечает за одну задачу
- **Open/Closed**: легко расширяется для поддержки других форматов (YAML, CSV)
- **Liskov Substitution**: интерфейсы позволяют заменять реализации
- **Interface Segregation**: четкое разделение ответственности
- **Dependency Inversion**: зависимости через конструкторы

### Расширяемость

Новые форматы подключаются через реализацию `DataComparator`:

1. Создайте класс, реализующий `DataComparator` (например, `YamlComparator`)
2. Опишите логику `supports`, `compare` и `compareWithMissing`
3. Добавьте компаратор в список в `Main`

## Обработка ошибок

- Поврежденный JSON: выводится предупреждение, файл пропускается
- Отсутствующий файл: отмечается как added/removed
- Ошибки доступа: логируются, не прерывают выполнение

## Логирование

Используется SLF4J с Simple Logger. Логи выводятся в консоль с уровнями:
- INFO: общая информация о процессе
- WARN: предупреждения (поврежденный JSON и т.д.)
- ERROR: критические ошибки
